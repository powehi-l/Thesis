\cleardoublepage

\section{绪论}

\subsection{研究背景与意义}

随着计算机科技的不断发展，各种计算机技术已经成为人们生活不可或缺的一部分，聊天软件、移动支付、影音技术都为日常生活带来极大的便捷。但是，这些技术在带来便捷的同时也导致了越来越多的安全问题。2021年4月，超过5.3亿Facebook用户的数据被泄露，其中包括姓名、出生日期、社交关系等敏感信息。2022年6月，西北工业大学发布声明称遭受境外的网络攻击，导致被窃取部分敏感信息。2023年6月，苹果iOS操作系统被曝存在安全漏洞，可能导致用户手机被黑客完全控制。由此可见，网络安全已经成为不可忽视的问题，个人的隐私及安全由此受到严重的威胁。因此需要尽量减少计算机系统中的漏洞，在让人们享受便捷的同时能够保护个人隐私安全。

与此同时，由于摩尔定律逐渐接近极限，多核处理器由于其对性能的提升被广泛地使用。相应地，由于并发编程模式能够充分发挥多核处理器的性能，因此也被编程人员青睐，合理的并发编程可以的大大提升程序运行的效率。但是这也引入了和顺序程序不同的安全漏洞，当并发程序不正确地处理多个线程之间的同步时就会导致并发错误，进而导致并发漏洞，黑客可以通过这些漏洞对系统发起攻击。例如，当多个线程对同一个变量的访问没有受到保护时，由于运行过程中线程执行的序列不同，最后变量的值被错误地更改，导致漏洞的产生。

目前已经有多种并发漏洞检测手段，包括静态检测、符号执行、模糊测试等，但是静态分析存在着准确率低，误报率高的缺点；符号执行的开销则会随着程序复杂度的提升迅速增大，而模糊测试可以在保证准确率的同时以可接受的开销来挖掘漏洞。随着计算机性能的提升以及AFL-ref的提出，模糊测试成为挖掘漏洞的重要手段。模糊测试最早由Barton Miller提出，最初用来测试程序的健壮性，后来才逐渐用于进行漏洞挖掘，模糊测试技术经过多次重要的发展，现在已经逐渐完善并得到广泛应用。但是由于并发程序的复杂性以及运行时的不确定性，并发漏洞能够被触发的概率很小，导致检测并发漏洞并稳定复现仍然存在困难。

当前通用的模糊测试工具只能处理通用地程序输入，而不能扩展到程序并发执行的维度，尽管目前存在一些对并发程序进行模糊测试的工作，但是都存在一定的局限性。因此本文主要探究将模糊测试应用在并发漏洞挖掘上，以实现高效的并发漏洞挖掘。


\subsection{国内外研究现状}

\subsubsection{利用部分顺序规约进行并发漏洞挖掘}

并发程序中线程或者进程的执行可能以多种方式交织，如果直接进行探索会导致状态空间呈指数级增长，在有状态的情况下甚至会造成状态爆炸，这对于当前的计算能力来说是不现实的，计算机无法在合理时间内对如此大量的情况进行探索，因此有必要提出一种能够减少并发程序探索空间的技术。部分顺序规约作为一种检查各个状态和行为间的独立性以减小整体的状态空间的技术，正好可以应用到并发漏洞挖掘，通过识别关键数据的依赖关系，将等价的并发程序交织归约到同一个集合，每一个集合只需要执行一次就可以对集合中的所有情况进行检测。

早在2005年，Flanagan\cite{flanagan2005dynamic}等人通过动态地跟踪进程间的相互作用，识别出需要回溯的点，从而探索状态空间中的替代路径。最终结果显示动态的部分顺序规约可以在线程不断增多的情况下避免状态爆炸的产生。

2014年，Abdulla\cite{abdulla2014optimal}等人提出了一种新的动态部分顺序规约算法并实现工具optimal-DPOR，通过引入源集合记录当前某个调度点上的所有可能的操作，避免探索与已探索的执行等价的执行路径，从而减少冗余探索。同时这篇文章还引入了唤醒树机制，控制未来探索的初始步骤，确保算法不会遇到任何睡眠集阻塞的探索。最终实验结果显示，optimal-DPOR在导致不超过10\%开销的情况下加速了并发空间的探索。

2019年，Abdulla\cite{abdulla2019optimal}等人提出了首个针对顺序一致性语义下的多线程程序的无状态模型检查算法，算法基于一种更粗粒度的等价关系——reads-from，这种关系保留了从写操作到读操作的依赖关系，但放宽了对执行顺序的要求。通过精确地探索每个“reads-from”等价类中的一个执行路径，避免对等价的执行路径进行重复探索。根据这个算法，作者实现了Nidhugg/rfsc并进行了大量测试，首先，Nidhugg/rfsc在某些情况下比最快的SMC工具慢，但在其他情况下，它在探索执行数量上的性能要么类似，要么更好，并且在某些程序中比其他工具快指数级。其次，在测试的49个程序中，Nidhugg/rfsc在大多数程序中找到了bug，并且在其中一些程序中，它是唯一能够找到bug的工具。通过进一步分析，Nidhugg/rfsc可以正确地识别出多线程程序中的reads-from relation。

\subsubsection{利用模糊测试进行漏洞挖掘}

2019年，Jeong\cite{jeong2019razzer}等人开发了Razzer，通过静态分析（point-to analysis）识别，得到所有可能产生冲突的指令对，就是可能访问同一个地址的属于不同线程的两条指令，并得到所有可能产生冲突的指令对集合。然后进行单线程模糊测试以得到可以使程序执行到特定访存指令的输入。然后进行多线程测试，利用单线程测试得到的输入以及断点插入，使得程序按照规划好的顺序交错执行，然后观察是否会让程序发生异常或者其他错误。相比于Syzkaller，这一方法可以用更少的变异、执行次数找到更多的有效bug。但是Razzer的执行速度相比于Syzkaller更慢，并且利用point-to-analysis可能无法找到所有的冲突指令对。

2020年，Hongxu Chen\cite{chen2020muzz}等人提出了MUZZ，这篇文章首先通过静态分析得到可能会产生冲突的scope，然后对这些scope进行插桩。然后进行fuzzing的过程，利用前面插桩 的代码，得到代码覆盖率，线程上下文，交错顺序三个信息，并根据这些信息进行种子的选择，排序，变异，生成新的测试用例。最后利用T-Sanitize检测漏洞。相比于之前的 工作，MUZZ能够产生出更多和多进程相关的种子，也就是说能够测试更多多线程的用例。 同时相比于AFL等工具能够检测出更多的数据争用缺陷.。

2020年，Meng Xu\cite{xu2020krace}等人提出了KRACE，通过引入一个新的覆盖跟踪指标，别名覆盖率，来捕获并发维度的探索进度。通过这个新的维度，结合一种用于生成、变异、合并多线程 系统调用序列的进化算法，引导fuzzer对线程并发空间进行更有效的探索。相对于Syzkaller，KRACE可以发现更多的branch path。但是也会引入更大的开销。 

2022年，Zu-Ming Jiang\cite{jiang2022context}等人通过引入并发调用对这个新的并发覆盖指标，确保上 下文敏感性，并提出了一种邻接导向突变，生成新的可能的线程交错。这篇文章提出了 CONZZER 框架，并在8个用户级程序和4个内核级文件系统上进行了测试，并发现了95个数据竞争，其中75个是有害的。 

2023年，Jeong等人提出SEGFUZZ\cite{jeong2023segfuzz}，将对整个线程的交错空间进行分解，对一小段代码进行探索，然后再将多个小段代码合并再进行探索，并提出交织段覆盖率的概念，再提高发现并发错误的准确性的同时，避免了冗余测试。这很大程度上降低了并发空间探索的复杂度。SEGFUZZ在linux内核中发现了21个新的并发错误，并且这些错误都表现出有害行为。并且相对于 Snowboard和KRACE这些之前的工作能够更快地发现并发错误（平 均快 4.1 倍）。 

2023年，Ming Yuan等人开发了DDRACE\cite{yuan2023ddrace}，提出了新的距离度量反馈，RPIP（Race Pair Interaction Profile）反馈，约束反馈，来指导生成新的输入，并利用一种交错优先级 方案来选择更有可能产生并发访问缺陷的输入。相对于Syzkaller，RAZZER，KRACE这些工具，DDRACE可以发现更多的并发访问缺陷，并且可以在更短时间内发现。


\subsection{论文主要研究内容}

本文的主要工作是探究利用模糊测试进行并发漏洞挖掘，对目前已有的工作进行了详尽的分析，仔细分析并复现了利用读取关系缩减搜索空间的算法，并和灰盒模糊测试结合，以提高模糊测试的效率。具体来说主要的工作是构建了并发程序的reads-from relation，并利用这个关系作为反馈引导模糊测试的方向。

本篇文章实现了基于reads-from relation的并发漏洞模糊测试器RFF，对它的整体有效性以及其中各个部分的有效性作了完整评估

本篇文章复现了多种并发漏洞挖掘工具，包括PERIOD，PCT，POS等，并将这些工具和RFF进行对比。结果说明了RFF算法的有效性。

\subsection{论文的组织结构}

本文总共分为5个章节，具体的组织结构如下

第一章--绪论\par
这一章首先对研究的背景进行介绍，并提出将要研究的问题，指出研究的必要性。针对研究问题的国内外相关工作进行介绍，针对当前研究的痛点难点进行分析。最后简要概括主要研究内容以及本文的组织结构。\par\par
第二章--背景知识\par
这一章主要是对研究问题的背景知识以及工作里面会用到的知识进行介绍。其中包括竞争条件的产生、危害，模糊测试技术的整体介绍和在并发漏洞领域的应用，模糊测试过程中会用到的其他辅助技术。\par\par
第三章--研究工作\par
这一章是研究的主题部分，主要介绍针对研究问题，目前提出的工作的相关原理，以及本论文进行复现的主要框架和算法。并在最后对各种技术进行了总结和对比。\par\par
第四章--实验内容\par
这一部分对第三章复现的工具进行了测试，对RFF工具的有效性，reads-from relation概念以及抽象调度的有效性进行了验证，证明了RFF工具确实优于之前的工具。\par\par
第五章--总结与展望\par
结合第三章和第四章的内容，对当前工具的实际表现进行评估并分析原因。介绍个人的工作内容以及未来的工作方向。

\section{背景知识}

本章对相关的背景知识进行详细的介绍。第一个部分是对并发漏洞的介绍，对常见的并发漏洞模式进行梳理,指出其特点。然后整体介绍通用模糊测试，然后介绍模糊测试究竟是什么，其利用到的一些技术。

\subsection{竞争条件}

\subsubsection{竞争条件的产生}

竞争条件是指电子设备、软件或者其他系统的实质性行为取决于其他不可控的顺序或者时间，从而导致意外或者不一致的结果。如果其中一种或者多种行为是不能接受的 情况，它就会成为一个漏洞。其中关键的就是其输出的不确定性，正常情况下计算机会按照编写的代码严格地执行，就像数学中的逻辑一样严谨，给定同一个输入，那么任意次的测试中，系统都会有相同的输出。但是对于多线程程序，同样的输入，却有可能导致不同的输出结果。为了简单起见，这里讨论单核情况下的多线程程序。

\begin{spacing}{1.0}
\begin{lstlisting}[%
    language={C},
    caption={simple.c},
    label={code:racecondition},
]
int a = 0;
int thread1(){
    // ...
    reg = a;            (1)
    reg = reg + 1;      (2)
    a = reg;            (3)
    // ...
}
int thread2(){
    // ...
    reg = a;            (4)
    reg = reg - 1;      (5)
    a = reg;            (6)
    // ...
}
\end{lstlisting}
\end{spacing}

假设一个程序\autoref{code:racecondition}包含两个线程，两个线程都会访问同一个变量a，线程1将a增加1，线程2将a减去1。那么就会出现以下几种情况：

\begin{enumerate}
\item $(1) \Rightarrow (2) \Rightarrow (3) \Rightarrow (4) \Rightarrow (5) \Rightarrow (6)$
\item $(1) \Rightarrow (2) \Rightarrow (4) \Rightarrow (3) \Rightarrow (5) \Rightarrow (6)$
\item $(1) \Rightarrow (4) \Rightarrow (2) \Rightarrow (5) \Rightarrow (3) \Rightarrow (6)$
\end{enumerate}

如\autoref{fig:data_race}所示，在第一种情况下，thread1正常将a的值进行改变并写回，使a的值增加1，在写回之后thread2开始操作，将a的值减一并写回，最终a的值仍然为0，结果正确。

\begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{data_race}
    \caption{\label{fig:data_race}Data Race}
\end{figure}


在第二种情况下，thread1首先将a的值0读到reg并加1，然后thread2将a的值0读到thread2的reg中，随后thread1将1写入到a中，但是由于thread2最后直接将-1写入到a中，原本thread1写进去的1会被直接覆盖，导致得到一个错误的结果。第三种情况和第二种情况类似。

简单分析可知，发生错误的根本原因在于(4)在(3)之前发生了，这导致两个线程同时拿到了a的数据并进行处理，最终写回的时候就会出现覆盖的情况，导致错误。两个线程在他们自己线程中的处理都是正确的，但是从多个线程的视角来看，由于线程调度顺序的可能不同，每一次运行程序得到的结果都可能不一样。

而多线程程序的调度往往受随机条件影响，例如操作系统的进程调度器可能受到其他进程的影响，导致当前线程的调度出现偏差；外部的中断也可以打断线程的调度，而中断由外界的变化而引起，因此往往是随机化的，进而导致多线程调度的随机性。

\subsubsection{避免竞争条件的方式}

避免数据竞争主要要求程序员在编写多线程程序时严格遵守一些规则和原则包括但不限于同步，有序性和原子性。避免数据竞争的策略目前有很多，例如：

\begin{enumerate}
\item 首先，可以使用锁定机制确保任何时候只有一个线程访问数据。在执行读写操作之前，线程必须获得锁，读写完成后解锁。这样其他所有尝试获取锁的线程就会被阻塞，直到持有锁的线程完成操作。这种方法可以有效的防止数据竞争，但也 可能导致锁竞态和性能问题。
\item 其次，可以使用原子操作确保操作不受线程切换影响。所谓的原子操作，就是在执行中不会被线程切换打断的操作。一些编程语言提供了对原子操作的支持，如C++11中的std::atomic。
\item 然后，另一种策略是设计无共享数据的程序。既然数据竞争是由于多个线程同时访问同一块数据，那么避免共享数据就可以避免数据竞争。这种策略有时候被称为消息传递，其中线程之间通过发送消息来交换信息。每个线程有自己的数据副 本，因此不存在数据竞争。然而，这种方法可能会增加数据复制和通信的成本。
\item 最后，可以使用一些诸如事务性内存的较新的并发控制技术。在事务内存模型中，一组读取和写入被组合在一个事务中，只有当没有其他线程访问被事务使用的数据时，这个事务才能成功提交。
\end{enumerate}

以上就是防止数据竞争的一些常见策略和技术。谨记，无论使用哪种策略，在编写并 发代码时，始终需要注意数据访问的顺序和时机，以及线程如何互相影响。

\subsection{模糊测试}

模糊测试（Fuzz Testing或Fuzzing）是一种软件测试技术，它通过自动或半自动方式向系统提供无效、意外或随机的数据，并监控系统的响应，从而查找可能的错误和漏洞。模糊测试是通过大量的输入测试来检查程序是否存在异常状况，比如崩溃或者未捕获 的异常，是一种健壮性测试。随机生成数据是因为尽管在对开发的软件进行测试的过程中会覆盖到各种情形例如正向测试、反向测试、边界值、超长等场景，但是却无法对尽可能多的数据进行自动测试，无法覆盖到所有情况。并且随着当前的系统越来越复杂，一个软件的供应链往往涉及到成百上千个上游库、中间件、第三方组件，当这些组件和软件本身结合起来的时候可能会产生开发人员意想不到的结果。

模糊测试主要包括以下三个部分，如\autoref{fig:fuzzer}\cite{zhu2022fuzzing}所示：

\begin{enumerate}
\item 输入生成器：用于生成程序的输入。例如通过随机生成器创建大量的输入数据，包括各种数据类型和格式，以达到涵盖系统可能遇到的各种情况的目的.
\item 执行器：利用上一步的输入进行实际程序的执行.在这个过程中模拟系统的输入，可能涉及到用户输入、网络通信、文件读取等。
\item 反馈监控：在程序运行时或程序运行结束之后检测是否有异常发生。通过记录系统对输入的反应，包括崩溃、异常行为、错误信息、资源占用情况等信息，进而分 析系统是否发生了异常的行为。同时这些信息也可以为输入生成器提供反馈，生成新的输入.
\item 结果分析：对每一个引发异常的输入数据进行分析，确定这是一个真实的漏洞，还是一个假阳性。如果是一个真实的漏洞，那么就需要进一步分析并修复。
\end{enumerate}

\begin{figure}[ht]
    \centering
    \includegraphics[width=\linewidth]{fuzzer}
    \caption{\label{fig:fuzzer}模糊测试的关键步骤}
\end{figure}


在模糊测试系统运行时，首先生成示例输入，然后利用输入运行程序，并在程序运行过程中进行监视，如果过程中发现异常，则将这一个输入记录下来。并利用获得的信息生成下一轮测试所需的输入，再次进行测试。在实际应用中，模糊测试通常结合了生成测试和变异测试的思想。它可以应用于各种软件系统，包括应用程序、操作系统、驱动程序、网络协议等，以帮助发现并修复潜在的安全漏洞和软件缺陷。总的来说，模糊测试是一种强大的测试方法，可以帮助提高软件系统的健壮性和安全性，尤其是对于大规模、复杂的软件系统来说，模糊测试具有重要的意义。

\subsection{其他技术}

\subsubsection{插桩}

插桩技术指在保证原有程序逻辑完整性的基础上，在程序中插入探针，通过探针采集代码中的信息（方法本身、方法参数值、返回值等）在特定的位置插入代码段，从而收集程序运行时的动态上下文信息。一般来说插桩技术一般有以下用途：

\begin{enumerate}
\item 插入额外代码：在源代码的编写过程中，可能需要插入额外的代码来使程序的功能完整，或者需要在编译过程中插入生成的元数据。这些插入的代码或者数据和原本的代码没有关系，通常是用来执行特定的任务比如说收集数据和执行检查。
\item 代码分析：插桩技术可以在程序编译时进行，将特定的检查代码插入到程序的特定位置，然后在程序运行时可以检查代码的结构是否正确，进而确定代码的结构或者逻辑是否正确。插桩也可以动态进行，在程序运行的过程中将代码插入，用来监控代码的执行情况并提供反馈。
\item 数据收集：通过插入记录分析的代码，可以收集程序执行过程中的数据，如函数调用情况、变量的值变化、代码执行路径、分支执行情况等等，这些数据对于性能分析、调试、安全分析都有很大的作用。
\end{enumerate}

这对于模糊测试来说非常有意义，因为模糊测试需要重复生成测试用例并在每一轮测试的时候选取最佳的用例运行程序，因此如何生成更好的测试用例以及最佳的测试用例的选择就可以通过收集前面运行过的程序信息来进行。具体来说，例如通过插桩收集运行时程序的代码覆盖率，通常来说，代码覆盖率越高，相应检测到bug的概率可能会更大，因此有着更高代码覆盖率的的程序会被选取并进行变异生成新的测试用例。

\subsubsection{符号执行}

符号执行作为一类程序分析技术，其不同于具体执行将精确值视为代码的输入，而是将输入值抽象为符号值，并将代码内的分支视为对符号值的约束进行累积，当到达目标代码语句时，相应的分析器也会得到由符号值组成的约束条件路径，此时，可以用该约束条件路径来反求出程序执行某条路径的输入值。一般来说，符号执行有如下的用途：

\begin{enumerate}
\item 软件测试：在软件测试中，往往需要大量的测试用例来测试程序中的各个分支代码语句，通过符号执行，可以自动生成所需的测试用例，在减少工作量的同时并提高测试用例对于软件的覆盖率。
\item 程序分析：当程序出错时，符号执行技术可以根据程序出错的代码位置从而抽象出相应的符号约束条件，并反推出相应的输入值，以便于对程序错误的分析和解决。
\end{enumerate}

符号执行对于模糊测试也具有相当的意义，由于模糊测试需要利用相当数量的测试样例作为输入来发现软件的漏洞，因此，可以利用符号执行来反推出测试样例用于模糊测试，同时，可以提高测试样例对于被测软件的覆盖率。我们假设程序中各处中出现bug的概率都是一样的，因此，测试样例对于被测软件的覆盖率越高，发现bug的概率也就越大，从而提升了模糊测试的性能。

\subsubsection{污点分析}

污点分析是一种信息流分析技术，其设置了污点源和污点汇聚点，其中，污点源一般指引入非法数据，而污点汇聚点是指产生了不安全的行为。当由污点源引入的污点数据并不会直接传播至污点汇聚点，而是要先进行无害处理，则说明该程序系统的信息流安全，反之则说明其信息流存在安全隐患。

污点分析通常分为显示流分析和隐式流分析。其中，显示流分析指的是分析污点数据在程序当中随着程序变量是如何传递的，从而获得各个变量间的数据依赖关系；隐式流分析指的是分析污点数据在程序执行当中是如何根据变量间的控制关系进行传递的，更关注的是控制依赖关系。

一般而言，污点分析有如下的用途：
\begin{enumerate}
\item 漏洞检测：对于程序进行污点分析，通过观察污点源引入的污点数据在程序中的流向，以便于工作人员分析程序中隐藏的安全漏洞，并在后续中进行修复，从而提升程序的安全性能。
\item 信息流安全分析：污点分析本身就是一种信息流安全分析技术，其通过利用程序变量间的数据依赖关系或者控制依赖关系来分析污点数据的流动，从而判断信息流安全与否。
\item 隐私数据泄露检测：污点分析技术可以利用程序当中变量间的依赖关系，将隐私数据标记为污染源，从而获得隐私数据在程序中的流动路径，进而便于判断隐私数据在系统中是否泄露。
\end{enumerate}