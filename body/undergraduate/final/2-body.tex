% \cleardoublepage

\section{研究工作}
% \cite{jeong2019razzer, chen2020muzz, xu2020krace, jiang2022context}
这一章主要介绍本篇文章\cite{wolff2024greybox}研究的几种工作的主要内容，各自的设计，以及各自实验的效果，并进行对比。当前模糊测试的主流是灰盒测试，如\cite{jeong2019razzer}，这些工具利用灰盒测试，收集多线程程序运行过程中的线程交错信息，如别名覆盖率\cite{xu2020krace}等，来指导线程交错信息的变异。前面的主要都是基于变异的方式来进行模糊测试，但是这些工具有一个缺点就是无法生成一个比较好的初始输入，这会导致工具的探索效率随机性太高，可能在某个初始输入比较好的情况下，工具的性能非常高，在短时间内就可以探索到并发漏洞。但是如果初始输入不合适，可能花费大量时间也无法探索到能产生并发漏洞的线程交错情况，甚至根本无法找到，因为线程交错空间随着程序长度增加呈指数级上升，以当前的计算机能力几乎无法穷尽。

\subsection{RFF}

在\cite{wolff2024greybox}这篇论文中，Wolff等人通过将Reads-from Relation引入到模糊测试中来生成抽象调度，来代表一个等价调度集合，通过测试这个调度集合中的一个调度就可以代表整个集合。同时文章还将Reads-from作为新的反馈，利用这个度量引导模糊测试器进行后续的探索。下面将对RFF的相关核心思想进行介绍。

\subsubsection{概述}

当前用灰盒模糊测试检测并发漏洞的工具主要有以下几个特点。首先，灰盒模糊测试器保留一个调度的集合，这个集合中的每一项都是一个调度，可以用来对多线程程序进行测试。其次，调度集合是所有调度集合的一个子集，因此模糊测试器会在每一轮测试中从这个集合中选取一个最佳的项用于进行测试。为了量化调度之间优劣关系，模糊测试器就会通过代码覆盖率反馈来量化调度是否是足够好的，目前也有许多其他形式的反馈被提出来，用于更加准确地反馈多线程程序的交错程度。

尽管当前的处理已经能够发现许多由多线程程序引起并发漏洞，但是由于多线程程序和常规的单线程程序有很大的不同，仍然还是有许多问题有待解决，他们对于提升模糊测试的效率有极大的影响。
\begin{enumerate}
\item 多线程的线程交错的可能数量是非常大的，但是可以导致并发漏洞的交错在其中只占很小一部分。
\item 传统的反馈度量如代码覆盖率在单线程情况下很合适，工作得很不错，但是在多线程的情况下代码覆盖率只能有助于探索单线程的代码深度，但是对于多线程的交错的不同情况不能有效进行探索。
\item 模糊测试器生成的多线程程序的一种调度并不一定能够在实际情况下执行。例如在实际情况中两个线程需要切换的位置都处于同一把锁的保护之下，在实际情况中不能在这个位置进行切换，而且这还会在模糊测试的时候浪费时间，造成测试的效率降低。
\end{enumerate}
后面将尝试解决这几个问题，进而提升模糊测试的效果。

\subsubsection{Reads-from Relation}

Reads-from Relation是这篇工作的核心概念，后面的改进都是基于这个概念。文章中希望通过等价调度的概念来较少探索的空间，而作者使用Reads-from Relation来构建等价调度集合。并基于这个想法实现了最终的算法。

为了定义reads-from relation，首先需要定义event和schedule。event是一个五元组$e = <id, t, op, x, \rho>$, 其中id是五元组e的唯一标识，t是一个线程标识，op是这个五元组进行的操作，包括写和读两种操作，x是op进行操作的对象（内存地址等），最后$\rho$表示操作的在代码中的位置。而一个schedule$\sigma$是一系列的events的集合。一个schedule的reads-from function就是一个函数，它的自变量是这个schedule中的所有读操作，这些读操作所读取的地址由其他写操作进行了写的操作，它的因变量是写入一个特定地址的写操作，这个地址会被自变量的读操作所读取。这个reads-from function记为$rf_{\sigma}$。如果两个schedule的events的集合相同并且reads-from function也相同，就说这两个schedule是reads-from等价的。

将reads-from relation作为基础构建等价调度集是合理的。首先我们在Section 2.1.1中提到过，竞争条件发生的根本原因是是由于读写错位导致的，所以说调整读写的顺序，也就能对不同的可能发生错误的情况进行尝试。在整个多线程程序运行的过程中，除了读和写的操作，其他的操作不会和其他线程产生交集，因此也不会造成并发的错误，这也是为什么reads from relation没有对除了读和写之外的操作进行记录。

为了简单起见，这里首先分析两个操作的情况下为什么会产生并发错误。如果两个操作都是读的话，这种情况下并不会发生并发的错误，但是在两个操作中，有一个是写的操作时就会导致错误，比如说第一个操作对一个位置进行了写的操作，第二个位置原本想要读取这个地方的值，但是被写操作覆盖了，所以说现在他读到了错误的值。而reads-from relation就正好能够定义这种读取其他的操作所写的值的情况，不同的reads-from relation就正好对应不同的读取其他操作写值的情况，因此，利用reads-from relation定义不同的schedule是比较合适的。

\subsubsection{抽象事件及调度}

再定义了reads-from relation以及等价调度之后，这篇文章进一步定义了抽象事件和抽象调度。用来对一整个等价的调度集合进行表示，一个抽象的调度就能够表示一整个等价调度的集合。同时，抽象调度是一种实际的数据结构，可以作为后续进一步实现变异操作的基础。

一个抽象事件是一个三元组$ea=<op, x, \rho>$，其中op表示读操作或者写操作，x表示操作的对象或地址，$\rho$表示操作代码的位置。一个抽象调度就是一系列的正向和反向reads-from约束。一个正向调度就是一对具有reads-from relation的抽象事件。正向和反向调度就分别代表了一个线程跳向另一个线程和跳回来的过程。一个具体的调度就是所有具体的事件进行排列的序列。当两个具体的调度同时符合一个抽象调度时，就说明这两个调度是等价的，那么就可以将它们，归到同一个类中，进而只需要测试他们中的一个，就可以代表这整个等价调度类。

正如前面所说，定义了抽象调度及其数据结构，就可以方便地对它进行变异。因为前面定义的抽象调度是一系列抽象事件的集合，因此只需要对抽象事件的顺序或数量等进行变异，就可以进一步改变抽象调度。在文章中定义了四种变异的方式，分别是插入，交换，删除以及反向。文章的$mutate\_schedule$函数首先选取一种变异的方式，然后随机选取存在潜在矛盾的抽象事件，然后对这些矛盾的抽象事件进行变异到得到新的抽样调度，并且会保证新产生的抽象调度不会和前面的重复。

\subsubsection{Reads-from反馈和调度实现}

本篇文章除了使用通常灰和模糊测试所使用的控制流反馈，还使用了With from信息，作为并发探索空间的反馈。 当变异后的调度中包含其他之前调度都没有的新的reads-from关系，或者一个调度导致了程序崩溃，算法就会认为这个调度是有趣的，并加入到种子集合中。并且在每次选取种子时，模糊测试器还会进一步将探索的方向偏移到那些很少出现的with from约束的调度上去

 在产生了前面的抽象调度之后，模糊测试器需要利用这个调度在实际的运行时进行操作，实际的操作就是通过维持一个当前可运行指令的状态图，这个状态图通过指定相应操作的优先级来保证对应指令是否能够运行。例如对于一个特定的reads-from constraint，如果写操作和读操作都就绪，那么将读操作的优先级调低，保证先进性写操作，在进行读操作。在写操作完成之后，将读的优先级调高，并将其他对该地址写的操作的优先级调低，这样就可以保证能够按照调度的方序来运行相应的指令。这是一种稳定的实现调度的方式，能够保证在多线程的情况下，程序仍旧按照指定的运行顺序进行运行，避免了不确定性。同时，尽可能保证了低开销。

\subsection{PERIOD}

\subsubsection{概述}

正如前文所提到的，当前利用模糊测试挖掘并发漏洞的研究已经有了通用的流程，但是对于一些关键的问题仍然没有解决。比如多线程交错空间往往很大，但是能够导致并发错误的调度往往只占其中的很小一部分。在这么大的空间中，找到那一小部分调度是一个很关键的问题。再比如，在实际运行程序进行测试的过程中，如何根据一个已有的调度信息去控制多线程程序，按照相应的调度运行。这篇文章主要针对其中的两个问题

\begin{enumerate}
\item 在进行实际的多线程程序运行的时候，如何保证受控的程序调度？虽然目前已经有很多种方案被提出，比如通过插装来实现抢占，睡眠延迟，或者动态线程优先级的修改。但是这些调度技术有可能和原本程序中的同步原语产生冲突，进而导致其他问题。例如，通过插桩来引入抢占式同步，往往也是利用锁机制，在引入这些锁同步机制之后，新的程序有可能会产生死锁。而利用睡眠延迟来同步，可能会被其他事件打断而产生不可预测的后果，而且这种方式可能会造成比较大的时间开销，造成测试效率降低。
\item 如何有效的探索调度空间？正如前文所说，程序调度空间的大小是会随着程序中调度点的数量的增多而指数级增长。想要穷尽调度空间，往往是不现实的。现有的工作大多以随机或者系统的方式探索调度空间，但是随机探索只能保证发现错误的概率，而系统测试在有限的指令中进行探索,尽管如此，它所需要探索的空间仍然很大，会造成比较大的开销。
\end{enumerate}

\subsubsection{动态关键点切片}

这里首先应该定义关键点，关键点就是一个对变量的访问的操作，基于这些对变量的访问，将一个单线程的程序进行切片，然后把它们组合为多线程的这个执行顺序，在这个切片的边界是对一个变量的访问。这篇文章将每一个切片称作为一个period。这篇文章同样观察到，并发漏洞往往发生在不同线程对相同变量的访问，并且这两个访问都靠近于程序进行切换时，所以对同一个变量访问时进行线程切换且切换到的程序访问同一个变量是最有可能产生并发漏洞的。因此，period通过系统的探索不同的程序切片方式，进而构造出可能产生并发漏洞的关键点切片。

\begin{lstlisting}[%
    language={C},
    caption={period1.c},
    label={code:period1},
]
if(done);                                       //period1
++waiters;
mutex_lock(lock); 
if(!done) 
    done=1; 
mutex_unlock(lock); 
if(!--waiters){ 
    free(lock); 
    lock = NULL; 
} 
                            if(done)            //period2
                                return 0;
\end{lstlisting}

这种方式还有一个好处就是它可以挖掘更深层次的并发漏洞。并发漏洞在大多数情况下都只涉及几个指令的访问。但是，在少数情况下可能涉及多个访问。Period基于这种系统探索保留前缀切片，在后续的切片中进行继续的探索，从而能够更深层次的对程序的并发访问空间进行探索，挖掘到更深层次的漏洞。

例如多线程程序\autoref{code:period1}。其中对done这个变量进行了多次的访问，尽管对访问做了一定的保护，但是仍然有可能产生并发漏洞。PERIOD通过将period1进行拆分来找到可能的冲突切片。以对period1进行切片为例，PERIOD逐个将最后一条指令分到PERIOD3中去，然后如果切换的边界点正好同样是对done的访问，则视为一个有趣的切片，并对其进行进一步的探索。这里首先将$lock = NULL$分到period3，然后再将$free(lock)$也分到period3，直到$done = 1$被分配到period3。此时代码的交错为\autoref{code:period2}。由于此时thread2的代码执行路径变化的了，因此相应的代码段也产生变化。至此，PERIOD发现了一个新的关键点切片，在此基础上会对period2进行下一次的切片，并不断持续下去。注意这种方式不一定会导致状态爆炸，因为在探索的过程中，有很多情况被舍弃掉了。当线程切换上下文两个指令并不都是对同一个变量或地址的访问时，这种切片不会被period保留下来并进行进一步探索，只有在上下文的为关键点时period才会保留下来并进行进一步的探索。

\begin{lstlisting}[%
    language={C},
    caption={period2.c},
    label={code:period2},
]
if(done);                                       //period1
++waiters;
mutex_lock(lock); 
if(!done) 

                            if(done)            //period2
                            ++waiters;
    done=1;                                     //period3
mutex_unlock(lock); 
if(!--waiters){ 
    free(lock); 
    lock = NULL; 
} 
                            mutex_lock(lock); 
                            if(!done)
                            mutex_unlock(lock);
                            if(!--waiters){ 
                                free(lock); 
                                lock = NULL; 
                            }
\end{lstlisting}

\subsubsection{Periodical Executor}

这篇文章要解决的第二个问题是基于生成的调度，在实际测试程序时，将多线程程序的运行序列化。前面提到之前的工作，可能会和原本程序的机制产生冲突，进而导致不可预知的情况发生。这篇文章使用了周期性的执行机制，它基于linux的Deadline任务调度，通过在每一个key point点之前设置$sched_yield$函数，在执行到这个函数时，会将当前线程挂起并执行其他线程。PERIOD会分配一个生命周期，每个period的生命周期都足够长来覆盖任何period中的关键点。当生命周期结束时，一个周期的执行也就结束了。

这种机制为线程的同步引入了一种可靠的机制，因为它是依托于操作系统原本设计的机制，因此，在使用时可以调用操作系统的接口，依托于操作系统的健壮性，具有比较高的可靠性。

\subsection{PCT}

Probabilistic Concurrency Testing是一种用于挖掘并发漏洞的随机算法。和前面的方法类似，这种方法同样是尝试将可能的输入减少，达到提高效率的目的。具体来说，它通过给定的线程数量，步骤数量以及漏洞深度（能够发现漏洞的最小调度限制数量）来对交错空间进行探索。同时，利用随机生成的算法，在数学上证明可以以稳定的概率发现漏洞。

\subsection{POS}
\subsection{QLearning RF}
\subsection{RFF与其他工具的比较}